
First, install Mininet from source
http://mininet.org/download/
# Make sure you use the install.sh -nfv option


https://www.tecmint.com/create-network-bridge-in-ubuntu/
https://askubuntu.com/questions/1037704/how-to-create-a-bridge-from-a-wifi-laptop
# JUST USE nm-connection-editor
https://techandtrains.com/2013/11/24/mininet-host-talking-to-internet/


https://www.researchgate.net/publication/305782558_Mininet-WiFi_A_Platform_for_Hybrid_Physical-Virtual_Software-Defined_Wireless_Networking_Research?enrichId=rgreq-777369ce3497c8be114c9535c853bf91-XXX&enrichSource=Y292ZXJQYWdlOzMwNTc4MjU1ODtBUzo0MDk0OTgwODM3MDg5MzRAMTQ3NDY0MzM1OTg3MA%3D%3D&el=1_x_3&_esc=publicationCoverPdf
# They show some setup where they are connecting Mininet to a physical AP
https://www.youtube.com/watch?v=WH6bSOKC7Lk
# Same as above, just a video



Issues:
- Remember to allow the bash scripts to be executable.

Notes:
- My python code is setup so listening/binding is the local host and a particular port, but sending data is using a mininet address and the original particular port.

- When an external host sends data, they must send data first to the mininet server, and then within that data have another message 
- THe other option is to have each external host map to a particular interface on the Mininet server, which actually corresponded to some switch.  The switches are 
then connected together like originally...and external hosts use the IP for each interface - thus we just task each external host to a particular interface designating their grouping/tier.  The issue with this approach is that you can't do mobility experiments, since Mininet only has switches.



Thoughts:
- We could have PIs just talk to each other via the Mininet device, where
    each one is connected via Ethernet.  However, when PIs want to talk to each other, they actually talk via the virtual addresses...
    So PI with address 172.17.60.4 actually has vaddress 10.0.0.2
    So another PI would talk to this one via the 10.0.0.2 address.
    Mininet would have to do two things:
        - Identify the source virtual address


- In our CE work we had each host have its own python receiver and transmitter
    Similarly in Heliot there were virtual containers which established connections with a real device.
    See https://github.com/nesl/Heliot/blob/master/main/Scenario_hardcoded/network.py

    
# USeful commands

SCPing a file to to the rpi
scp external_send.py pi@172.17.60.5:/home/pi/IoCT-Testbed
scp external_recv.py pi@172.17.60.6:/home/pi/IoCT-Testbed

Calling the external clients:

python external_recv.py --intermediate_address 172.17.15.11 --intermediate_port 55001 --origin_id rpi2

python external_send.py --intermediate_address 172.17.15.11 --intermediate_port 55001 --destination_id rpi2 --origin_id rpi1



# Our Addresses:
RPI1: pi@172.17.60.5
RPI2: pi@172.17.60.6
edge-machine: brianw@172.17.15.11

By default, each host has port 55000 open for communication, with the exception of edge-machine, which has 55000 open in addition to multiple other ports corresponding to each additional device (e.g. RPI1)


# ISSUES:
When you run the test_mininet.py, make sure to run this additional command:
'''ts1 ifconfig ts1-eth1 10.0.0.1'''
This is what allows internal mininet hosts to talk to the mininet switch

If you lose WiFi on your host machine or other machines, you should double check your ip routes - it's possible that you messed up the default route and it routes through ethernet rather than WiFi for default.


# Steps to enable the desired networking
- Change the IP route of every RPI to route via the IP of the host machine
-  You must also change the IP route of every RPI such that the default src changes to the new IP.
e.g. "sudo ip route del default dev INTERFACE_NAME scope link src OLD_IP"
to "sudo ip route add default dev INTERFACE_NAME scope link src NEW_IP"


- On the host machine, you have to enable promiscuous mode on the ethernet connetcted to the RPIs
You can do this via "ip link set DEV_NAME promisc on"  and similarly for "off"
- Make sure that the firewall is off - otherwise the python code will get blocked.
-  Don't forget to disable IP forwarding - otherwise the RPis will still talk to each other. "sudo sysctl -w net.ipv4.ip_forward=0"

The host machine is basically running a packet sniffer on its ethernet interface.
Install Scapy: https://scapy.readthedocs.io/en/latest/installation.html

- Change the ip route on the host machine (for each RPI address) to be the loopback address.

One of the issues of changing the IP route to be the loopback address is that
 then packets never go beyond the host address.


 # Steps for setup
- First you have to start your mininet program
    This automatically disables ipv4 forwarding
    This should also automatically run ts1 ifconfig ts1-eth1 10.0.1.7
- Then you refresh the RPI's ip route (del and add)
    This might not be necessary since ipv4 forwarding was disabled earlier.


# Overview:
So what happens when rpi1 sends a packet?
-Firstly, RPI1 has an ip routing rule that prevents it from sending directly to RPI2, it must go through the host machine.
- The packet is received by a sniffer on the host machine, which also has IP forwarding disabled.  The packet is processed and converted into a mininet address at the translator.  THe translator also has routing rules which sends packets to RPI2vhost via RPI1vhost.  It is also creating a spoofed packet where
the source and destination IPs are of the RPIvhosts.  
- The RPIvhosts recieve the packet and forward it to either:
  - the translator - this happens if the destination IP of the packet
        matches the current vhost.
  - otherwise, the packet is sent to the next RPIvhost (with some IP converting)
- The translator node receives the finalized packet, which looks identical to the one that it had seen when it read in (IPs are all external again).
- It then sends it to the appropriate RPI destination.



# ERROR CHECKLIST
Your iproute configuration on host machine should only have default for the WiFi
Your iproute configuration on the RPIs should be default dev INTERFACE_NAME scope link src 10.0.0.X
 # Notes to self
 #  I added an ip route for default enp8s0